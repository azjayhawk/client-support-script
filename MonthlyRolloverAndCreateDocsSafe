/****************** SAFE MONTHLY ADD-ON (no duplicates, faster) ******************/

// ---- CONFIG (adjust if needed) ----
const MT_SHEET             = 'Master Tracker';
const TEMPLATE_ROW_IDX     = 2;   // template row with formulas/validation
const FIRST_DATA_ROW_IDX   = 2;
const REPORT_FOLDER_COL    = 18;  // R: "Open Folder"
const REPORT_DOC_COL       = 19;  // S: "Open Doc"
const HIDDEN_KEY_HEADER    = 'KEY';     // hidden stable key
const HIDDEN_DOCID_HEADER  = 'DOC_ID';  // hidden Google Doc ID
const LOGO_FILE_ID         = '1fW300SGxEFVFvndaLkkWz3_O7L3BOq84'; // your logo
const PARENT_FOLDER_ID     = '1UI4zQ_YIEWWJT0kSP2x8EaQlue303Xl-'; // parent for client folders

// ---- UTILITIES ----
function normalizeId_(v){ return String(v||'').toLowerCase().trim(); }
function monthToYYYYMM_(labelOrDate){
  let d = (labelOrDate instanceof Date) ? labelOrDate : new Date(String(labelOrDate) + ' 1');
  if (isNaN(d)) d = new Date();
  const y = d.getFullYear(), m = String(d.getMonth()+1).padStart(2,'0');
  return `${y}-${m}`;
}
function buildMonthlyKey_(monthLabel, clientName){
  return `${monthToYYYYMM_(monthLabel)}||${normalizeId_(clientName)}`;
}

// Ensure KEY + DOC_ID columns exist (hidden) and return their indexes
function ensureHiddenColumns_(){
  const sh = SpreadsheetApp.getActive().getSheetByName(MT_SHEET);
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];

  function ensureCol(header){
    let idx = headers.indexOf(header)+1; // 1-based
    if (idx <= 0){
      const insertAt = sh.getLastColumn()+1;
      sh.insertColumnAfter(sh.getLastColumn());
      sh.getRange(1, insertAt).setValue(header);
      sh.hideColumns(insertAt);
      return insertAt;
    } else {
      if (!sh.isColumnHiddenByUser(idx)) sh.hideColumns(idx);
      return idx;
    }
  }
  return { keyCol: ensureCol(HIDDEN_KEY_HEADER), docIdCol: ensureCol(HIDDEN_DOCID_HEADER) };
}

function findRowByKey_(sh, keyCol, key){
  const total = sh.getLastRow();
  if (total < FIRST_DATA_ROW_IDX) return -1;
  const rng = sh.getRange(FIRST_DATA_ROW_IDX, keyCol, total - FIRST_DATA_ROW_IDX + 1, 1).getValues();
  for (let i=0;i<rng.length;i++){
    if (String(rng[i][0]) === key) return FIRST_DATA_ROW_IDX + i;
  }
  return -1;
}

function copyTemplateRowTo_(sh, targetRow){
  const lastCol = sh.getLastColumn();
  sh.getRange(TEMPLATE_ROW_IDX, 1, 1, lastCol).copyTo(
    sh.getRange(targetRow, 1, 1, lastCol),
    { contentsOnly: false }
  );
}

// ---- DRIVE HELPERS ----
function getOrCreateClientFolder_(parentFolder, name){
  const it = parentFolder.getFoldersByName(name);
  return it.hasNext() ? it.next() : parentFolder.createFolder(name);
}
function findMonthlyDocInFolder_(folder, name){
  const it = folder.getFilesByName(name);
  return it.hasNext() ? it.next() : null;
}

// ---- UPSERT CORE (with in-memory index) ----
function buildKeyIndex_(sh, keyCol){
  const last = sh.getLastRow();
  const map = new Map();
  if (last >= FIRST_DATA_ROW_IDX){
    const keys = sh.getRange(FIRST_DATA_ROW_IDX, keyCol, last - FIRST_DATA_ROW_IDX + 1, 1).getValues();
    for (let i=0;i<keys.length;i++){
      const k = String(keys[i][0] || '');
      if (k) map.set(k, FIRST_DATA_ROW_IDX + i);
    }
  }
  return map;
}

function upsertMonthlyRowWithIndex_(sh, keyCol, docIdCol, indexMap,
  monthLabel, clientName, folderUrl, docUrl, docId){
  const key = buildMonthlyKey_(monthLabel, clientName);
  let row = indexMap.get(key) || -1;

  if (row === -1){
    const last = sh.getLastRow();
    sh.insertRowsAfter(last, 1);
    row = last + 1;
    copyTemplateRowTo_(sh, row);
    sh.getRange(row, 1).setValue(monthLabel);  // Col A
    sh.getRange(row, 2).setValue(clientName);  // Col B
    sh.getRange(row, keyCol).setValue(key);
    indexMap.set(key, row);
  } else {
    sh.getRange(row, 1).setValue(monthLabel);
    sh.getRange(row, 2).setValue(clientName);
  }

  if (folderUrl) sh.getRange(row, REPORT_FOLDER_COL).setFormula(`=HYPERLINK("${folderUrl}", "Open Folder")`);
  if (docUrl)    sh.getRange(row, REPORT_DOC_COL).setFormula(`=HYPERLINK("${docUrl}", "Open Doc")`);
  if (docId)     sh.getRange(row, docIdCol).setValue(docId);

  return row;
}

// ---- DOC CREATION (fast path via DOC_ID; single search fallback) ----
function ensureAndFillMonthlyDocFast_(folder, name, existingDocId, rowData, tz){
  let file, doc;

  // Open directly by ID if we have one
  if (existingDocId){
    try {
      doc = DocumentApp.openById(existingDocId);
      file = DriveApp.getFileById(existingDocId);
    } catch(e) { /* fall through to search/create */ }
  }

  if (!doc){
    file = findMonthlyDocInFolder_(folder, name);
    if (file){
      doc = DocumentApp.openById(file.getId());
    } else {
      doc = DocumentApp.create(name);
      file = DriveApp.getFileById(doc.getId());
      folder.addFile(file);
      // remove from My Drive root only
      const rootId = DriveApp.getRootFolder().getId();
      const parents = file.getParents();
      while (parents.hasNext()){
        const p = parents.next();
        if (p.getId() === rootId) p.removeFile(file);
      }
    }
  }

  // (Re)write body content (mirrors your current doc layout)
  const body = doc.getBody();
  body.clear();
  try {
    const logoBlob = DriveApp.getFileById(LOGO_FILE_ID).getBlob();
    const image = body.appendImage(logoBlob);
    const targetWidth = 250;
    const ar = image.getHeight()/image.getWidth();
    image.setWidth(targetWidth).setHeight(targetWidth*ar);
  } catch(e){ Logger.log('Logo insert failed (continuing): ' + e); }

  const [clientName, blockUsed, remainingBlock, uncoveredOverage, firstName, domainExpire, accessToGA] = rowData;
  body.appendParagraph(`Hello ${firstName || ''},\n`);
  body.appendParagraph('');
  body.appendParagraph(`Here‚Äôs your monthly support summary for ${clientName} ‚Äì ${name.split(' - ')[0]}:`);
  body.appendParagraph(`Block Hours Applied: ${blockUsed || 0}`);
  body.appendParagraph(`Remaining Block Balance: ${remainingBlock || 0}`);
  body.appendParagraph(`Overage Hours (Uncovered): ${uncoveredOverage || 0}`);
  body.appendParagraph('');
  body.appendParagraph('\nIf you need additional support hours, visit https://radiateu.com/request-support-time.');
  body.appendParagraph('');
  body.appendParagraph('\nFor our clients on a monthly plan:');
  const tzId = tz || Session.getScriptTimeZone();
  const formattedDomainExpire = (domainExpire instanceof Date)
    ? Utilities.formatDate(domainExpire, tzId, 'MMM dd, yyyy')
    : (domainExpire || 'N/A');
  body.appendParagraph('üîê Domain Expiration: ' + formattedDomainExpire);
  body.appendParagraph('üìä Access to Google Analytics: ' + (accessToGA || 'N/A'));
  body.appendParagraph('\nIf you have any questions, feel free to reply here or send a message to support@radiateu.com.');
  doc.saveAndClose();

  return { url: doc.getUrl(), id: doc.getId() };
}

// ---- SAFE DRIVER (uses your existing Master Tracker as source) ----
function monthlyRolloverAndCreateDocsSafe(){
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName(MT_SHEET);
  const tz = ss.getSpreadsheetTimeZone();

  // prior month label (same behavior as your current script)
  const d = new Date(); d.setMonth(d.getMonth()-1);
  const monthLabel = Utilities.formatDate(d, tz, 'MMMM yyyy');

  const parentFolder = DriveApp.getFolderById(PARENT_FOLDER_ID);
  const { keyCol, docIdCol } = ensureHiddenColumns_();
  const data = sh.getDataRange().getValues();
  if (data.length <= 1) return;

  // Build key index once (O(n))
  const keyIndex = buildKeyIndex_(sh, keyCol);

  let changed = 0;
  for (let i=1;i<data.length;i++){
    const row = data[i];
    const clientName = (row[1] || '').toString().trim();               // B
    const planType   = (row[2] || '').toString().trim().toLowerCase(); // C
    const status     = (row[14]|| '').toString().trim().toLowerCase(); // O
    if (!clientName || planType === 'hosting' || status === 'inactive' || status === 'transitioning') continue;

    const clientFolder = getOrCreateClientFolder_(parentFolder, clientName); // uses name as your current flow
    const docName = `${monthLabel} - ${clientName}`;

    // fast path: existing DOC_ID from this row (if previously set)
    const existingDocId = row[docIdCol - 1] || null;

    const { url, id } = ensureAndFillMonthlyDocFast_(
      clientFolder,
      docName,
      existingDocId,
      [
        clientName,
        row[7]  || 0, // H: Block Used
        row[8]  || 0, // I: Remaining
        row[9]  || 0, // J: Overage (Uncovered)
        row[12] || '',// M: First Name
        row[15] || '',// P: Domain Expire
        row[16] || '' // Q: Access to GA
      ],
      tz
    );

    upsertMonthlyRowWithIndex_(
      sh, keyCol, docIdCol, keyIndex,
      monthLabel, clientName,
      clientFolder.getUrl(), url, id
    );

    changed++;
  }

  SpreadsheetApp.getUi().alert(`‚úÖ ${changed} support summaries created/updated (safe mode).`);
}

// ---- DEDUPE UTILITY (optional) ----
function dedupeMonthSafe(monthLabelOpt){
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName(MT_SHEET);
  const tz = ss.getSpreadsheetTimeZone();
  const { keyCol, docIdCol } = ensureHiddenColumns_();
  const ym = monthToYYYYMM_(monthLabelOpt || Utilities.formatDate(new Date(), tz, 'MMMM yyyy'));

  const last = sh.getLastRow();
  if (last < FIRST_DATA_ROW_IDX) return 0;

  const all = sh.getRange(FIRST_DATA_ROW_IDX, 1, last - FIRST_DATA_ROW_IDX + 1, sh.getLastColumn()).getValues();
  const rowsToDelete = [];
  const seen = new Map();

  for (let i=0;i<all.length;i++){
    const absRow = FIRST_DATA_ROW_IDX + i;
    const monthText = all[i][0];
    const key = all[i][keyCol - 1];
    if (!key) continue;
    if (monthToYYYYMM_(monthText) !== ym) continue;

    if (!seen.has(key)){
      seen.set(key, i);
    } else {
      const keepIdx = seen.get(key);
      const keepUrl   = all[keepIdx][REPORT_DOC_COL - 1];
      const dupeUrl   = all[i][REPORT_DOC_COL - 1];
      const keepDocId = all[keepIdx][docIdCol - 1];
      const dupeDocId = all[i][docIdCol - 1];

      if (!keepUrl && dupeUrl) sh.getRange(FIRST_DATA_ROW_IDX + keepIdx, REPORT_DOC_COL).setValue(dupeUrl);
      if (!keepDocId && dupeDocId) sh.getRange(FIRST_DATA_ROW_IDX + keepIdx, docIdCol).setValue(dupeDocId);

      rowsToDelete.push(absRow);
    }
  }

  rowsToDelete.sort((a,b)=>b-a).forEach(r => sh.deleteRow(r));
  SpreadsheetApp.getUi().alert(`üßπ Removed ${rowsToDelete.length} duplicate row(s) for ${ym}.`);
  return rowsToDelete.length;
}

// ---- OPTIONAL MENU (kept separate so your current menu stays unchanged) ----
function onOpen_AddSafeItems(){
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('üõ°Ô∏è Client Tools (Safe)')
    .addItem('üìÑ Run Monthly (Safe, no duplicates)', 'monthlyRolloverAndCreateDocsSafe')
    .addItem('üßπ Deduplicate This/Chosen Month', 'menuDedupeMonthPrompt_')
    .addToUi();
}
function menuDedupeMonthPrompt_(){
  const ui = SpreadsheetApp.getUi();
  const resp = ui.prompt('Deduplicate Month', 'Enter month label (e.g., "July 2025"). Leave blank for current month.', ui.ButtonSet.OK_CANCEL);
  if (resp.getSelectedButton() !== ui.Button.OK) return;
  const label = (resp.getResponseText() || '').trim();
  dedupeMonthSafe(label || null);
}